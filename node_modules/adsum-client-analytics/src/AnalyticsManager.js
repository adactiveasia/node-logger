/** @module ACAN */

import check from "check-types";
import {MD5} from "crypto-js";

import Options from "./Options";
import Request from "./Request";

//let version = require('../src/Version');

const _options = new WeakMap();
const _request = new WeakMap();
const _xhr = new WeakMap();

const _running = new WeakMap();
const _piwikUid = new WeakMap();
const _flushTimeout = new WeakMap();

const defaultOptions = {
    distEndPoint: "http://analytics.adsum.io/piwik.php",
    localEndPoint: "local-analytics",
    analyticsSite: 1,
    token: "",
    site: 1,
    device: 1,
    dataFolder: "./data",
    logLevel: "debug",
    flushInterval: 120000,
    pingInterval: 10000
};
/**
 * Class AnalyticsManager.
 * @property {module:ACA~Options} options
 * @property {Object} xhr
 * @property {boolean} running
 * @property {string} cache
 * @property {string} piwikUid
 * @property {Number} flushTimeout
 */
class AnalyticsManager {
    /**
     * @param {Object} options Json object
     */
    constructor(options) {

        const analyticsOptions = new Options();

        analyticsOptions.distEndPoint = this._getOption(options, "distEndPoint");
        analyticsOptions.localEndPoint = this._getOption(options, "localEndPoint");
        analyticsOptions.analyticsSite = this._getOption(options, "analyticsSite");
        analyticsOptions.token = this._getOption(options, "token");
        analyticsOptions.site = this._getOption(options, "site");
        analyticsOptions.device = this._getOption(options, "device");
        analyticsOptions.dataFolder = this._getOption(options, "dataFolder");
        analyticsOptions.logLevel = this._getOption(options, "logLevel");
        analyticsOptions.flushInterval = this._getOption(options, "flushInterval");
        analyticsOptions.pingInterval = this._getOption(options, "pingInterval");

        this.options = analyticsOptions;

        this.piwikUid = "";
        this.flushTimeout = 0;
        this.running = false;

        _xhr.set(this, null);
    }

    get options() {
        return _options.get(this);
    }

    set options(options) {
        check.assert.instance(options, Options);

        return _options.set(this, options);
    }

    _getOption(options, key) {
        return typeof options === "object" && options.hasOwnProperty(key) ? options[key] : defaultOptions[key];
    }

    getDefaultOptions() {
        return defaultOptions;
    }

    get request() {
        return _request.get(this);
    }

    set request(request) {
        check.assert.instance(request, Request);

        return _request.set(this, request);
    }

    get XMLHttpRequest() {
        return _xhr.get(this) === null && typeof XMLHttpRequest !== "undefined" ? XMLHttpRequest : _xhr.get(this);
    }

    set XMLHttpRequest(xhr) {
        _xhr.set(this, xhr);

        return this;
    }

    get piwikUid() {
        return _piwikUid.get(this);
    }

    set piwikUid(piwikUid) {
        check.assert.string(piwikUid);

        return _piwikUid.set(this, piwikUid);
    }

    get flushTimeout() {
        return _flushTimeout.get(this);
    }

    set flushTimeout(flushTimeout) {
        check.assert.number(flushTimeout);

        return _flushTimeout.set(this, flushTimeout);
    }

    get running() {
        return _running.get(this);
    }

    set running(running) {
        check.assert.boolean(running, "Should be a boolean");

        return _running.set(this, running);
    }

    /**
     * @return {boolean} The AnalyticsManager has been started
     */
    isRunning() {
        return this.running;
    }

    /**
     * Start the AnalyticsManager
     * @return {Object} this
     */
    start() {
        if (this.isRunning()) {
            return;
        }
        this.running = true;

        this.resetUserId();

        this.flush();

    }

    /**
     * Ping function to adsum server
     * @return {Promise} Xhr promise
     */
    ping() {
        console.info("Sending ping");

        const data = {
            idsite: this.options.analyticsSite,
            rec: 1,
            url: "http://" + this.options.site + ".adsum.io/log/ping",
            _id: this.piwikUid,
            uid: this.piwikUid,
            rand: AnalyticsManager.generateNounce().toString(),
            apiv: 1,
            cvar: this._cvarEncode({"DeviceId": this.options.device}),
            token_auth: this.options.token,
            send_image: 0,
            //ua: `APA Server: ${version.self}`,
            cdt: parseInt(Date.now() / 1000)
        };

        this.request = new Request();
        this.request.url = this.options.distEndPoint;
        this.request.addData(data);

        return this.xhr(this.request, 200);
    }

    flush() {

    }

    /**
     * Send monitoring information to adsum server with severity level
     * @param {number} id severity level
     * @param {string} message Log message
     * @return {Promise} Xhr promise
     */
    trackLog(id, message) {
        let severity = null;
        switch (Math.trunc(id / 1000)) {
            case 1:
                severity = "INFO";
                break;
            case 2:
                severity = "NOTICE";
                break;
            case 3:
                severity = "WARN";
                break;
            case 4:
                severity = "ERROR";
                break;
            case 5:
                severity = "FATAL";
                break;
            default:
                console.error(`Code severity not found for ${id})`);
                return;
        }

        const data = {
            idsite: this.options.analyticsSite,
            rec: 1,
            url: "http://" + this.options.site + ".adsum.io/log/" + severity + "/" + id,
            _id: this.piwikUid,
            uid: this.piwikUid,
            rand: AnalyticsManager.generateNounce().toString(),
            apiv: 1,
            cvar: this._cvarEncode(
                {
                    "DeviceId": this.options.device,
                    message
                }
            ),
            token_auth: this.options.token,
            send_image: 0,
            //ua: `APA Server: ${version.self}`,
            cdt: parseInt(Date.now() / 1000)
        };

        this.request = new Request();
        this.request.url = this.options.distEndPoint;
        this.request.addData(data);

        return this.xhr(this.request, 200);

    }

    /**
     * Send analytics information to adsum server
     * @param {string} type Action type
     * @param {number} id of the poi or category or element you want to track
     * @param {string} widgetId String describing the view
     * @return {Promise} Xhr promise
     */
    trackView(type, id, widgetId) {

        check.assert.string(widgetId);

        const data = {
            idsite: this.options.analyticsSite,
            rec: 1,
            url: "http://" + this.options.site + ".adsum.io/window/" + type + "/view/" + id,
            _id: this.piwikUid,
            uid: this.piwikUid,
            rand: AnalyticsManager.generateNounce().toString(),
            apiv: 1,
            cvar: this._cvarEncode(
                {
                    "DeviceId": this.options.device,
                    "WidgetId": widgetId
                }
            ),
            token_auth: this.options.token,
            send_image: 0,
            //ua: `APA Server: ${version.self}`,
            cdt: parseInt(Date.now() / 1000)
        };

        this.request = new Request();
        this.request.url = this.options.distEndPoint;
        this.request.addData(data);

        return this.xhr(this.request, 200);
    }

    resetUserId() {
        this.piwikUid = AnalyticsManager.generateNounce().toString();
    }

    xhr(request, expectedStatus) {
        return new Promise(
            (resolve, reject) => {
                if (request.data.length === 0) {
                    resolve();
                    return;
                }

                const data = JSON.stringify({
                    requests: ["?" + request.formattedData()],
                    token_auth: this.options.token
                });

                request.addHeaders({
                    "Content-Type": "application/x-www-form-urlencoded"
                });

                const XHR = this.XMLHttpRequest;
                const xhr = new XHR();
                xhr.open(request.method, request.url, true);
                xhr.withCredentials = false;

                const headerKeys = Object.keys(request.headers);
                for (let i = 0; i < headerKeys.length; i++) {
                    const key = headerKeys[i];
                    const value = request.headers[key];

                    xhr.setRequestHeader(key, value);
                }

                xhr.onload = (res) => {
                    switch (xhr.status) {
                        case expectedStatus:
                            resolve(xhr);
                            return;
                        case 502:
                        case 503:
                            console.warn("Server is busy", {status: res.statusCode});
                        // fall-through
                        default:
                            const message = `Unexpected status while requesting API, got ${xhr.status} instead of ${expectedStatus} n route ${request.formattedUrl()}`;
                            throw new Error(message);
                    }
                };

                xhr.onerror = (err) => {
                    console.warn("Unable to request api. An error occurred while requesting.", {}, err);
                    reject(Error("Network error"));
                };

                xhr.timeout = 10000;
                xhr.ontimeout = () => {
                    console.warn(
                        "Unable to request api. The request timeout is elapsed", {timeout: 10000}
                    );
                    reject();
                };

                xhr.send(data);
            }
        );
    }

    _getBaseHeaders() {
        return {
            "Content-Type": "application/json",
            "Access-Control-Allow-Headers": "Authorization,X-WSSE,DNT,Content-Range,X-CustomHeader,Keep-Alive,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,X-API-LOCALE",
            "Access-Control-Allow-Origin": "*",
            "Access-Control-Allow-Methods": "GET, OPTIONS",
            "Access-Control-Expose-Headers": "Content-Type, Content-Range, X-API-LOCALE",
            "Cache-Control": "public, max-age=0, must-revalidate"
        };
    }

    _500(res, next) {
        if (!res.headersSent) {
            res.writeHead(500, this._getBaseHeaders());
        }
        res.end();
        next();
    }

    _400(res, next) {
        res.writeHead(400, this._getBaseHeaders());
        res.end();
        next();
    }

    _404(res, next) {
        res.writeHead(404, this._getBaseHeaders());
        res.end();
        next();
    }

    _403(res, next) {
        res.writeHead(403, this._getBaseHeaders());
        res.end();
        next();
    }

    _204(res, next) {
        res.writeHead(204, this._getBaseHeaders());
        res.end();
        next();
    }

    /**
     * Encore cVar for piwik sever
     * @param {Object} cvar Json object
     * @return {string} Encoded string
     * @private
     */
    _cvarEncode(cvar) {
        const out = {};
        const keys = Object.keys(cvar);
        for (let i = 0; i < keys.length; i++) {
            const key = keys[i];
            out[i + 1] = ["" + key, "" + cvar[key]];
        }

        return JSON.stringify(out);
    }

    /**
     *
     * @return {string}
     * @private
     */
    static generateNounce() {
        const cryptoObj = typeof window === "undefined" ? null : window.crypto || window.msCrypto; // for IE 11
        if (cryptoObj) {
            const array = new Uint32Array(1);
            cryptoObj.getRandomValues(array);

            return MD5(array[0].toString(), 1);
        }

        const r = Date.now() * Math.random();

        return MD5(r.toString(), 1);
    }
}

export default AnalyticsManager;